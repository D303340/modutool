import { Pallete } from "style.slint";
import "../fonts/DS-DIGII.ttf";

export enum ButtonType {
    Normal,
    Warning, // YELLOW
    Critical, // RED
}

export enum Orientation {
    Vertical,
    Horizontal
}

export component Button inherits Rectangle {
    // Settings
    in property <ButtonType> type: Normal;
    in property <bool> enabled: true;

    // width: 100px;
    // height: 100px;

    // Background Colors
    in property <brush> bg-color: #26c4f4;
    in property <brush> bg-select-color: #007ba0;

    // Default Styles
    property <brush> bg-warning: #ffbb0f;
    property <brush> bg-critical: #f4233f;
    property <brush> bg-disabled: #24324c;


    // Icon
    in property <image> icon;
    in property <length> icon-width: 50px;
    in property <length> icon-height: 50px;
    in property <brush> icon-colorize;
    in property <angle> icon-rotation-angle: 0deg;


    // Text
    in property <string> text: "";
    in property <length> font-size: 16px;
    in property <int> font-weight: 500;
    in property <color> text-color: #ffffff;


    // Border
    in property <length> border-thickness;
    border-radius: border-thickness;


    // Set Default Color
    background: {
        if enabled {
            if type == ButtonType.Normal{
                bg-color
            }
            else if type == ButtonType.Warning {
                bg-warning
            }
            else if type == ButtonType.Critical {
                bg-critical
            }
            else { // DEFAULT 
                bg-color
            }
        }
        else {
            bg-disabled;
        }
    };


    // Icon
    Image {
        source: icon;
        width: icon-width;
        height: icon-height;
        rotation-angle: icon-rotation-angle;
        // image-fit: cover;
        colorize: icon-colorize;
    }


    // Text
    Text {
        text: root.text;

        font-size: root.font-size;
        font-weight: root.font-weight;

        color: text-color;
    }


    // Click Function
    callback clicked();

    ta := TouchArea {
        clicked => {
            if (enabled) {
                clicked();
                active = !active;
            }
        }
    } 

    property <bool> active: false;
    states [
        active when ta.pressed && enabled: {
            root.background: bg-select-color;
        }
    ] 
    
}

export component Radio inherits Rectangle {
    in property <bool> enabled: true;

    width: 50px;
    height: 50px;

    in property <length> border-thickness: 6px;
    in property <length> enabled-spacing: 18px;
    
    in property <brush> checkbox-border-color: Pallete.primary;
    in property <brush> checkbox-bg-color: transparent;
    in property <brush> checkbox-enabled-color: Pallete.primary;
    
    background: checkbox-bg-color;
    border-radius: self.width / 2;
    border-width: border-thickness;
    border-color: {
        if enabled {
            checkbox-border-color;
        }
        else {
            Pallete.disabled;
        }
    };


    Enable-Circle := Rectangle {
        background: {
            if enabled {
                checkbox-enabled-color;
            }
            else {
                Pallete.disabled;
            }
        };

        width: parent.width - border-thickness - enabled-spacing;
        height: parent.height - border-thickness - enabled-spacing;
        border-radius: self.width / 2;

        animate width {
             duration: 0.3s;
             easing: ease-out-back;
        }

        animate height {
            duration: 0.3s;
            easing: ease-out-back;
        }

        animate background {
             duration: 0.3s;
             easing: ease-out-quart;
        }
    }


    // Click Function
    callback clicked();

    ta := TouchArea {
        clicked => {
            if (enabled) {
                clicked();
                active = !active;
            }
        }
    } 

    property <bool> active: false;
    states [
        active when active: {
            Enable-Circle.background: transparent;
            Enable-Circle.width: + 2px;
            Enable-Circle.height: + 2px;
        }
    ] 
}

export component TextField inherits Rectangle {
    width: 250px;
    height: 75px;

    // text 
    in property <string> text: "TextField";
    in property <brush> text-color: #cacaca;
    in property <length> text-padding: 20px;
    in property <TextHorizontalAlignment> horizontal-alignment;
    in property <TextVerticalAlignment> vertical-alignment: center;

    // Background Colors
    in property <brush> bg-color: #423F3E;
    
    // Border
    in property <length> border-thickness: 1px;
    in property <brush> bg-border-color: #6C6C6C;


    background: bg-color;
    border-color: bg-border-color;
    border-width: border-thickness;

    Text {
        width: root.width - (border-thickness * 2) - text-padding;
        height: root.height - border-thickness - 0;

        horizontal-alignment: root.horizontal-alignment;
        vertical-alignment: root.vertical-alignment;

        text: root.text;
        font-size: 20px;

        color: text-color;
    }
}

export component ToggleSlide inherits Rectangle {
    in property <float> size: 1;
    in property <length> slide-offset: 14px;

    in property <brush> bg-on-color: #57c7ff;
    in property <brush> bg-off-color: #000000;

    width: 100px * size;
    height: 50px * size;
    border-radius: root.height / 2;
    background: #203d5e;
    
    slide := Rectangle {
        background: bg-on-color;
        
        height: root.height - (slide-offset * size);
        width: root.height - (slide-offset * size);
        
        border-radius: self.height / 2;
        
        x: root.height + ((slide-offset/2) * size);
        
        animate x {
            duration: 0.15s;
            easing: ease-in;
        }
        
        animate background {
            delay: 0.075s;
            duration: 0.15s;    
            easing: ease-out;
        }
    }
    
    // Click Function
    callback clicked();
    
    ta := TouchArea {
        clicked => {
            clicked();
            active = !active;
        }
    } 
    
    property <bool> active: false;
    states [
        active when active: {
            slide.background: bg-off-color;
            slide.x: (slide-offset/2) * size;
        } 
    ] 
}

export component ProgressBar inherits Rectangle {

    in property <Orientation> orientation: Orientation.Horizontal;

    in-out property <float> progress: 75;

    z: 1;
    in property <length> length: 200px;
    in property <length> thickness: 20px;

    in property <length> progress-bar-outer-radius: 999px;
    in property <length> progress-bar-inner-radius: 999px;

    in property <brush> bg-color: #24324c;
    in property <brush> bar-color: #26c4f4;

    background: bg-color;
    clip: true;
    
    width: {
        if orientation == Orientation.Vertical {
            thickness;
        }
        else {
            length;
        }
    } 
    height: {
        if orientation == Orientation.Vertical {
            length;
        }
        else {
            thickness;
        }
    } 
    border-radius: clamp(progress-bar-outer-radius, 0, min(length, thickness)/2);
    Bar := Rectangle {
        property <length> progress-bar: length * clamp((progress / 100), 0, 1);
        visible: progress > 0;
        width: {
            if orientation == Orientation.Vertical {
                thickness;
            } else {
                clamp(progress-bar, thickness, progress-bar);
            }
        }
        height: {
            if orientation == Orientation.Vertical {
                clamp(progress-bar, thickness, progress-bar);
            } else {
                thickness;
            }
        }
        border-top-left-radius: clamp(progress-bar-inner-radius, 0, min(length, thickness)/2);
        border-top-right-radius: clamp(progress-bar-inner-radius, 0, min(length, thickness)/2);
        border-bottom-left-radius: clamp(progress-bar-inner-radius, 0, min(length, thickness)/2);
        border-bottom-right-radius: clamp(progress-bar-inner-radius, 0, min(length, thickness)/2);
        y: {
            if orientation == Orientation.Vertical {
                length - clamp(progress-bar, thickness, progress-bar);
            } else {
                0px;
            }
        }
        x: {
            if orientation == Orientation.Vertical {
                0px;
            } else {
                // length - clamp(progress-bar, thickness, progress-bar);
                0px;
            }
        }
        z: 0;
        background: bar-color;
    }

}

export component Slider inherits Rectangle {
    
    width: 150px;
    height: 10px;

    in property <brush> empty-bar-color: Pallete.neutralB;
    in property <brush> filled-bar-color: Pallete.primary;
    in-out property <float> position: 25.0;
    in property <length> radius: 99px;

    in property <brush> knob-color: Pallete.neutralA;
    in property <length> knop-size: 20px;
    in property <length> knob-radius: 99px;

    bar := Rectangle {
        background: empty-bar-color;
        border-radius: clamp(radius, 0, self.height / 2);
        clip: true;

        filled := Rectangle {
            background: filled-bar-color;
            x: 0;
            width: root.width * (position / 100);
        }
    }

    
    knop := Rectangle {
        width: knop-size;
        height: knop-size;
        
        background: knob-color;
        border-radius: clamp(knob-radius, 0, knop-size / 2);
        
        // LOGIC
        x: (root.width * (position / 100)) - self.width / 2;
    }

    ta := TouchArea {
        property <int> pressed-value: 0;

        width: parent.width + 25px;
        height: parent.height + 10px;

        pointer-event(event) => {
            if(event.button == PointerEventButton.left && event.kind == PointerEventKind.down) {
                self.pressed-value = root.position;
            }
        }

        moved => {
            if(self.enabled && self.pressed){
                // root.position = clamp(self.pressed-value + (ta.pressed-x - ta.mouse-x) / (root.width - self.width), 0, 100);
                root.position = clamp(self.pressed-value + ((ta.mouse-x - ta.pressed-x) / root.width) * 100, 0, 100);

            }
        }
    }
}

export component TextLabel inherits Rectangle {
    in property <string> text: "Slider 1:";
    in property <brush> text-color: #b0b0b0;

    in property <length> font-size: 20px;
    in property <int> font-weight: 400;
    in property <bool> font-italic: false;
    
    in property <TextHorizontalAlignment> horizontal-alignment: left;
    in property <TextVerticalAlignment> vertical-alignment: center;

    height: 0;

    Text {
        text: root.text;
        color: text-color;

        font-size: root.font-size;
        font-weight: root.font-weight;
        font-italic: root.font-italic;

        vertical-alignment: root.vertical-alignment;
        horizontal-alignment: root.horizontal-alignment;
    }
}

export component BarChart inherits Rectangle { 
    width: 400px;
    height: 400px;

    in property <[int]> values: [2, 3, 6, 11, 17, 25, 36, 52, 72, 100];
    in property <int> max-value: 100;

    in property <length> bar-spacing: 5px;
    in property <length> bar-radius: 4px;
    in property <length> bar-padding: 100px;

    // Bars
    Bars := Rectangle {
        width: root.width - bar-padding;
        height: root.height - bar-padding;
        z: 1;

        for value[i] in values: Rectangle{
            x: mod(i, values.length) * parent.width / values.length + bar-spacing/2;
            width: parent.width / values.length - bar-spacing;
    
            height: value * parent.height / max-value;
            y: parent.height - self.height;
    
            border-top-left-radius: bar-radius;
            border-top-right-radius: bar-radius;


            border-bottom-left-radius: {
                if i == 0 {
                    bar-radius;
                }
                else {
                    0px;
                }
            }

            border-bottom-right-radius: {
                if i == values.length - 1 {
                    bar-radius;
                }
                else {
                    0px;
                }
            }
            
            
            background: #007acc;
        }
    } 

    // Frame
    property <int> name;
    for value[index] in 6: Rectangle{
        property <length> offset: index * Bars.height / 5;

        width: Bars.width;
        height: 1px;
        background: #ffffff33;
        y: root.height + 1px - (bar-padding / 2) - offset;

        VerticalLayout {
            x: 0px - self.width - 5px;
            y: 0px - 10px;
            Text {
                // y: 0px - self.font-size;
                text: max-value * value / 5;
    
                horizontal-alignment: right;
                font-size: 13px;   
            }
        }
    }
}
